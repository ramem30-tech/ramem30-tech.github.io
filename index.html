<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forest Foragers - 2D Multiplayer Survival</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #382b22;
            color: #ffffff;
            overflow: hidden;
            image-rendering: pixelated;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #5d9254;
        }
        .ui-container {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 20px;
            z-index: 10;
            padding: 0 20px;
            box-sizing: border-box;
        }
        .ui-panel {
            background-color: rgba(0, 0, 0, 0.6);
            border: 4px solid #5a4f49;
            box-shadow: 0 0 0 4px #2b211c;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #crafting-panel { flex-shrink: 0; }
        #hotbar-panel { flex-grow: 0; flex-shrink: 0; }
        #chat-panel { flex-grow: 1; min-width: 200px; max-width: 350px; }

        .ui-panel h3 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #f5f5f5;
            text-align: center;
        }
        .inventory-grid, .hotbar-grid, .crafting-grid { display: grid; gap: 4px; }
        .crafting-area { display: flex; align-items: center; gap: 10px; }
        .crafting-grid { grid-template-columns: repeat(2, 40px); grid-template-rows: repeat(2, 40px); }
        .hotbar-grid { grid-template-columns: repeat(9, 40px); }
        .inventory-slot {
            width: 40px; height: 40px; background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid #3b322d; display: flex; align-items: center;
            justify-content: center; font-size: 24px; cursor: pointer; position: relative;
        }
        .inventory-slot.selected { border-color: #ffd700; box-shadow: 0 0 5px #ffd700; }
        .inventory-slot:hover { background-color: rgba(255, 255, 255, 0.2); }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: white; text-shadow: 1px 1px 1px black; }
        .crafting-arrow { font-size: 24px; }
        .chat-container { width: 100%; height: 150px; display: flex; flex-direction: column; }
        #chat-messages { flex-grow: 1; overflow-y: auto; font-size: 10px; padding: 5px; background-color: rgba(0, 0, 0, 0.3); margin-bottom: 5px; line-height: 1.4; }
        #chat-input { width: 100%; background-color: rgba(0, 0, 0, 0.5); border: 2px solid #5a4f49; color: white; padding: 5px; font-size: 10px; }
        #name-container { position: absolute; top: 10px; left: 10px; z-index: 10; display: flex; align-items: center; gap: 10px; }
        #name-input, #set-name-btn { background-color: rgba(0, 0, 0, 0.5); border: 2px solid #5a4f49; padding: 5px; color: white; font-size: 10px; }
        #set-name-btn { cursor: pointer; }
        #user-id-display { position: absolute; top: 40px; left: 10px; z-index: 10; font-size: 10px; background-color: rgba(0,0,0,0.5); padding: 5px; }
        .loader { border: 8px solid #f3f3f3; border-top: 8px solid #5a4f49; border-radius: 50%; width: 60px; height: 60px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="game-canvas"></canvas>
    <div id="loading-overlay" class="absolute inset-0 bg-gray-800 bg-opacity-90 flex flex-col justify-center items-center z-50">
        <div class="loader"></div>
        <p class="text-white text-xl mt-4">Connecting...</p>
        <p id="loading-error" class="text-red-400 text-sm mt-2"></p>
    </div>
    <div id="name-container">
        <input type="text" id="name-input" placeholder="Enter your name..."><button id="set-name-btn">Set</button>
    </div>
    <div id="user-id-display">Your User ID: <span id="user-id"></span></div>
    <div class="ui-container">
        <div id="crafting-panel" class="ui-panel">
            <h3>CRAFTING</h3>
            <div class="crafting-area">
                <div id="crafting-grid" class="crafting-grid">
                    <div class="inventory-slot" data-idx="0"></div><div class="inventory-slot" data-idx="1"></div>
                    <div class="inventory-slot" data-idx="2"></div><div class="inventory-slot" data-idx="3"></div>
                </div>
                <div class="crafting-arrow">-></div>
                <div id="crafting-output" class="inventory-slot"></div>
            </div>
            <div id="inventory-panel" class="inventory-grid mt-4" style="grid-template-columns: repeat(9, 40px);"></div>
        </div>
        <div id="hotbar-panel" class="ui-panel">
            <div id="hotbar" class="hotbar-grid"></div>
        </div>
        <div id="chat-panel" class="ui-panel chat-container">
            <h3>CHAT</h3>
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Type message...">
        </div>
    </div>
    <div id="message-box" class="fixed top-5 right-5 bg-red-500 text-white p-4 rounded-lg shadow-xl hidden transition-opacity duration-300">
        <p id="message-text"></p>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, serverTimestamp, writeBatch, addDoc, getDocs, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- DOM Elements ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = loadingOverlay.querySelector('p:not(#loading-error)');
        const loadingErrorText = document.getElementById('loading-error');
        const nameInputEl = document.getElementById('name-input');
        const setNameBtnEl = document.getElementById('set-name-btn');
        const userIdDisplay = document.getElementById('user-id');
        const chatMessagesEl = document.getElementById('chat-messages');
        const chatInputEl = document.getElementById('chat-input');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');

        // --- Game Config ---
        const TILE_SIZE = 32; const MAP_WIDTH = 100; const MAP_HEIGHT = 100;

        // --- Game State ---
        let db, auth;
        let localPlayer = null; let otherPlayers = {}; let worldObjects = {};
        const keysPressed = {}; const camera = { x: 0, y: 0 };
        const gameState = { worldId: null, userId: null, unsubscribes: [], isAuthReady: false };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        const EMOJIS = { PLAYER: '‚óâ‚Äø‚óâ', AXE: 'ü™ì', PICKAXE: '‚õèÔ∏è', SWORD: '‚öîÔ∏è', WALL: 'üß±', TORCH: 'üî•', TREE_S: 'üå≥', TREE_M: 'üå≥', TREE_L: 'üå≥', ROCK: 'ü™®', ENEMY: 'üëª', BERRY: 'üçì', WOOD: 'ü™µ', STONE: '™®ò' };
        const CRAFTING_RECIPES = { 'AXE': { recipe: ['WOOD', 'WOOD', null, 'WOOD'], yields: 1 }, 'PICKAXE': { recipe: ['WOOD', 'WOOD', null, 'STONE'], yields: 1 }, 'WALL': { recipe: ['STONE', 'STONE', null, null], yields: 4 }, };
        let craftingGrid = [null, null, null, null]; let selectedInventoryItem = null;

        // --- Main Game Functions ---
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        function gameLoop() { if (!localPlayer) return; update(); render(); requestAnimationFrame(gameLoop); }

        function update() {
            const speed = 4; let dx = 0; let dy = 0;
            if (keysPressed['w'] || keysPressed['ArrowUp']) dy -= 1; if (keysPressed['s'] || keysPressed['ArrowDown']) dy += 1;
            if (keysPressed['a'] || keysPressed['ArrowLeft']) dx -= 1; if (keysPressed['d'] || keysPressed['ArrowRight']) dx += 1;
            if (dx !== 0 || dy !== 0) {
                const magnitude = Math.sqrt(dx * dx + dy * dy); const normalizedDx = (dx / magnitude) * speed; const normalizedDy = (dy / magnitude) * speed;
                let nextX = localPlayer.x + normalizedDx; let nextY = localPlayer.y + normalizedDy; let collision = false;
                for (const id in worldObjects) { const obj = worldObjects[id]; if (obj.type === 'WALL' || obj.type.startsWith('TREE') || obj.type === 'ROCK') { if (Math.hypot(nextX - obj.x, nextY - obj.y) < TILE_SIZE * 0.8) { collision = true; break; } } }
                if (!collision) {
                    localPlayer.x = nextX; localPlayer.y = nextY;
                    const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId);
                    setDoc(playerRef, { x: localPlayer.x, y: localPlayer.y, lastUpdate: serverTimestamp() }, { merge: true });
                }
            }
            camera.x = localPlayer.x - canvas.width / 2; camera.y = localPlayer.y - canvas.height / 2;
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.translate(-camera.x, -camera.y);
            for (const id in worldObjects) {
                const obj = worldObjects[id]; ctx.font = `${obj.size || TILE_SIZE * 0.8}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(EMOJIS[obj.type] || '?', obj.x, obj.y);
                if (obj.maxHealth && obj.health < obj.maxHealth) {
                    const barWidth = TILE_SIZE; const barHeight = 5; const barX = obj.x - barWidth / 2; const barY = obj.y - (obj.size || TILE_SIZE) * 0.8;
                    ctx.fillStyle = '#b91c1c'; ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = '#16a34a'; const healthPercentage = obj.health / obj.maxHealth; ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);
                }
            }
            for (const id in otherPlayers) {
                if (id === gameState.userId) continue; const player = otherPlayers[id]; ctx.fillStyle = 'white'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(EMOJIS.PLAYER, player.x, player.y - 20); ctx.font = '10px "Press Start 2P"'; ctx.fillText(player.name, player.x, player.y - 40);
            }
            if (localPlayer) {
                // PLAYER SPRITE - DO NOT CHANGE
                ctx.fillStyle = 'yellow'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(EMOJIS.PLAYER, localPlayer.x, localPlayer.y - 20); ctx.font = '10px "Press Start 2P"'; ctx.fillText(localPlayer.name, localPlayer.x, localPlayer.y - 40);
            }
            ctx.restore();
        }

// --- UI & Event Handlers ---
        function renderCraftingUI() { if (!localPlayer) return; const gridSlots = document.querySelectorAll('#crafting-grid .inventory-slot'); gridSlots.forEach((slot, i) => { const item = craftingGrid[i]; slot.innerHTML = item ? EMOJIS[item] || item : ''; }); const inventoryPanel = document.getElementById('inventory-panel'); inventoryPanel.innerHTML = ''; const allItems = Object.keys(localPlayer.inventory).sort(); allItems.forEach(item => { const count = localPlayer.inventory[item]; if (item && count > 0) { const slot = document.createElement('div'); slot.className = 'inventory-slot'; if (item === selectedInventoryItem) { slot.classList.add('selected'); } slot.innerHTML = `${EMOJIS[item] || item}<div class="item-count">${count}</div>`; slot.addEventListener('click', () => handleInventoryClick(item)); inventoryPanel.appendChild(slot); } }); }
        function updateHotbarUI() { if (!localPlayer) return; const hotbarPanel = document.getElementById('hotbar'); hotbarPanel.innerHTML = ''; for (let i = 0; i < 9; i++) { const slot = document.createElement('div'); slot.className = 'inventory-slot'; slot.dataset.idx = i; slot.classList.toggle('selected', i === localPlayer.selectedHotbar); const item = localPlayer.hotbar[i]; if (item) { const count = localPlayer.inventory[item] || 0; slot.innerHTML = `${EMOJIS[item] || item}${count > 1 ? `<div class="item-count">${count}</div>` : ''}`; } hotbarPanel.appendChild(slot); } }
        function checkCraftingRecipe() { const outputSlot = document.getElementById('crafting-output'); outputSlot.innerHTML = ''; for (const itemName in CRAFTING_RECIPES) { const recipeInfo = CRAFTING_RECIPES[itemName]; if (JSON.stringify(recipeInfo.recipe) === JSON.stringify(craftingGrid)) { outputSlot.innerHTML = `${EMOJIS[itemName] || itemName}<div class="item-count">${recipeInfo.yields}</div>`; break; } } }
        function showMessage(message, isError = true) { messageBox.className = `fixed top-5 right-5 p-4 rounded-lg shadow-xl transition-opacity duration-300 ${isError ? 'bg-red-500' : 'bg-green-500'} text-white`; messageText.textContent = message; messageBox.classList.remove('hidden'); setTimeout(() => { messageBox.classList.add('hidden'); }, 4000); }
        function handleInventoryClick(item) { selectedInventoryItem = selectedInventoryItem === item ? null : item; renderCraftingUI(); }
        document.getElementById('crafting-grid').addEventListener('click', (e) => { if (!e.target.closest('.inventory-slot')) return; const slot = e.target.closest('.inventory-slot'); const idx = parseInt(slot.dataset.idx); if (craftingGrid[idx]) { const item = craftingGrid[idx]; localPlayer.inventory[item] = (localPlayer.inventory[item] || 0) + 1; craftingGrid[idx] = null; } else if (selectedInventoryItem && localPlayer.inventory[selectedInventoryItem] > 0) { craftingGrid[idx] = selectedInventoryItem; localPlayer.inventory[selectedInventoryItem]--; if (localPlayer.inventory[selectedInventoryItem] <= 0) { delete localPlayer.inventory[selectedInventoryItem]; selectedInventoryItem = null; } } const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId); setDoc(playerRef, { inventory: localPlayer.inventory }, { merge: true }); renderCraftingUI(); checkCraftingRecipe(); });
        document.getElementById('crafting-output').addEventListener('click', () => { for (const itemName in CRAFTING_RECIPES) { const recipeInfo = CRAFTING_RECIPES[itemName]; if (JSON.stringify(recipeInfo.recipe) === JSON.stringify(craftingGrid)) { localPlayer.inventory[itemName] = (localPlayer.inventory[itemName] || 0) + recipeInfo.yields; craftingGrid = [null, null, null, null]; const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId); setDoc(playerRef, { inventory: localPlayer.inventory }, { merge: true }); renderCraftingUI(); checkCraftingRecipe(); return; } } });
        document.getElementById('hotbar').addEventListener('click', e => { if (!e.target.closest('.inventory-slot')) return; const slot = e.target.closest('.inventory-slot'); const idx = parseInt(slot.dataset.idx); if (selectedInventoryItem) { localPlayer.hotbar[idx] = selectedInventoryItem; selectedInventoryItem = null; const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId); setDoc(playerRef, { hotbar: localPlayer.hotbar }, { merge: true }); renderCraftingUI(); updateHotbarUI(); } });
        canvas.addEventListener('click', async e => { if (!localPlayer) return; const rect = canvas.getBoundingClientRect(); const clickX = e.clientX - rect.left + camera.x; const clickY = e.clientY - rect.top + camera.y; const selectedItem = localPlayer.hotbar[localPlayer.selectedHotbar]; let interacted = false; for (const id in worldObjects) { const obj = worldObjects[id]; if (Math.hypot(obj.x - localPlayer.x, obj.y - localPlayer.y) < TILE_SIZE * 1.5 && Math.hypot(obj.x - clickX, obj.y - clickY) < TILE_SIZE / 2) { if (obj.type.startsWith('TREE') || obj.type === 'ROCK') { let damage = 13; if ((obj.type.startsWith('TREE') && selectedItem === 'AXE') || (obj.type === 'ROCK' && selectedItem === 'PICKAXE')) { damage = 50; } const newHealth = obj.health - damage; const objRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "worldObjects", id); if (newHealth > 0) { setDoc(objRef, { health: newHealth }, { merge: true }); } else { let resourceToGain = null; let amountToGain = 0; if (obj.type.startsWith('TREE')) { resourceToGain = 'WOOD'; amountToGain = selectedItem === 'AXE' ? obj.woodYield : 1; } else if (obj.type === 'ROCK') { resourceToGain = 'STONE'; amountToGain = selectedItem === 'PICKAXE' ? 5 : 1; } if (resourceToGain) { localPlayer.inventory[resourceToGain] = (localPlayer.inventory[resourceToGain] || 0) + amountToGain; } const batch = writeBatch(db); batch.delete(objRef); const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId); batch.update(playerRef, { inventory: localPlayer.inventory }); await batch.commit(); } interacted = true; break; } } } if (!interacted && selectedItem === 'WALL' && (localPlayer.inventory.WALL || 0) > 0) { const gridX = Math.round(clickX / TILE_SIZE) * TILE_SIZE; const gridY = Math.round(clickY / TILE_SIZE) * TILE_SIZE; const wallRef = collection(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "worldObjects"); addDoc(wallRef, { type: 'WALL', x: gridX, y: gridY }); localPlayer.inventory.WALL--; const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId); setDoc(playerRef, { inventory: localPlayer.inventory }, { merge: true }); } });
        window.addEventListener('keydown', e => { keysPressed[e.key.toLowerCase()] = true; if (!isNaN(e.key) && e.key >= 1 && e.key <= 9 && localPlayer) { localPlayer.selectedHotbar = parseInt(e.key) - 1; updateHotbarUI(); const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId); setDoc(playerRef, { selectedHotbar: localPlayer.selectedHotbar }, { merge: true }); } });
        window.addEventListener('keyup', e => { keysPressed[e.key.toLowerCase()] = false; });
        chatInputEl.addEventListener('keydown', (e) => { if (e.key === 'Enter' && chatInputEl.value.trim() !== '') { if (!localPlayer || !localPlayer.name) return; const chatRef = collection(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "chat"); addDoc(chatRef, { senderName: localPlayer.name, text: chatInputEl.value.trim(), timestamp: serverTimestamp() }); chatInputEl.value = ''; } });
        window.addEventListener('resize', resizeCanvas);
        setNameBtnEl.addEventListener('click', () => { if (localPlayer && nameInputEl.value) { localPlayer.name = nameInputEl.value; const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId); setDoc(playerRef, { name: localPlayer.name }, { merge: true }).then(() => showMessage("Name updated!", false)); } });
        
        // --- Firebase Functions ---
        async function initFirebase() { try { const firebaseConfig = JSON.parse(__firebase_config); const app = initializeApp(firebaseConfig); db = getFirestore(app); auth = getAuth(app); onAuthStateChanged(auth, async (user) => { if (user) { gameState.userId = user.uid; userIdDisplay.textContent = user.uid; gameState.isAuthReady = true; await joinWorld(); } }); if (typeof __initial_auth_token !== 'undefined') { await signInWithCustomToken(auth, __initial_auth_token); } else { await signInAnonymously(auth); } } catch (error) { console.error("CRITICAL: Firebase Initialization failed:", error); loadingText.textContent = `Error connecting.`; loadingErrorText.textContent = error.message; } }
        async function joinWorld() { loadingText.textContent = "Joining World..."; const worldMetaRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId); const worldDoc = await getDoc(worldMetaRef); if (!worldDoc.exists()) { await generateWorld(); } await initPlayer(); setupListeners(); loadingOverlay.style.display = 'none'; gameLoop(); }
        async function generateWorld() { const batch = writeBatch(db); const worldMetaRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId); batch.set(worldMetaRef, { name: 'New World', createdAt: serverTimestamp() }); for (let i = 0; i < 200; i++) { const sizeRoll = Math.random(); let type, size, health, woodYield; if (sizeRoll < 0.5) { type = 'TREE_S'; size = TILE_SIZE * 0.7; health = 50; woodYield = 2; } else if (sizeRoll < 0.85) { type = 'TREE_M'; size = TILE_SIZE * 1.0; health = 100; woodYield = 5; } else { type = 'TREE_L'; size = TILE_SIZE * 1.4; health = 150; woodYield = 10; } const objRef = doc(collection(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "worldObjects")); batch.set(objRef, { type, x: Math.random() * MAP_WIDTH * TILE_SIZE, y: Math.random() * MAP_HEIGHT * TILE_SIZE, size, health, maxHealth: health, woodYield }); } for (let i = 0; i < 100; i++) { const health = 100; const objRef = doc(collection(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "worldObjects")); batch.set(objRef, { type: 'ROCK', x: Math.random() * MAP_WIDTH * TILE_SIZE, y: Math.random() * MAP_HEIGHT * TILE_SIZE, health, maxHealth: health }); } await batch.commit(); }
        async function initPlayer() { loadingText.textContent = "Loading Character..."; const playerRef = doc(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players", gameState.userId); const playerDoc = await getDoc(playerRef); if (playerDoc.exists()) { localPlayer = playerDoc.data(); } else { const { x, y } = await findSafeSpawn(); localPlayer = { x, y, name: gameState.userId.substring(0, 6), inventory: {}, hotbar: Array(9).fill(null), selectedHotbar: 0 }; await setDoc(playerRef, localPlayer); } nameInputEl.value = localPlayer.name; updateHotbarUI(); renderCraftingUI(); }
        async function findSafeSpawn() { const objectsQuery = query(collection(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "worldObjects"), limit(100)); const querySnapshot = await getDocs(objectsQuery); const tempObjects = querySnapshot.docs.map(doc => doc.data()); for (let i = 0; i < 100; i++) { const x = Math.random() * MAP_WIDTH * TILE_SIZE; const y = Math.random() * MAP_HEIGHT * TILE_SIZE; let isSafe = true; for (const obj of tempObjects) { if (Math.hypot(x - obj.x, y - obj.y) < TILE_SIZE * 2) { isSafe = false; break; } } if (isSafe) return { x, y }; } return { x: 100, y: 100 }; }
        function setupListeners() { gameState.unsubscribes.forEach(unsub => unsub()); gameState.unsubscribes = []; const objectsQuery = query(collection(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "worldObjects")); const unsubObjects = onSnapshot(objectsQuery, (snapshot) => { snapshot.docChanges().forEach((change) => { const data = change.doc.data(); const id = change.doc.id; if (change.type === "added" || change.type === "modified") { worldObjects[id] = data; } else if (change.type === "removed") { delete worldObjects[id]; } }); }); gameState.unsubscribes.push(unsubObjects); const playersQuery = query(collection(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "players")); const unsubPlayers = onSnapshot(playersQuery, (snapshot) => { otherPlayers = {}; snapshot.forEach(doc => { if (doc.id !== gameState.userId) { otherPlayers[doc.id] = doc.data(); } else { localPlayer = { ...localPlayer, ...doc.data() }; updateHotbarUI(); renderCraftingUI(); nameInputEl.value = localPlayer.name; } }); }); gameState.unsubscribes.push(unsubPlayers); const chatQuery = query(collection(db, "artifacts", appId, "public", "data", "worlds", gameState.worldId, "chat"), orderBy("timestamp", "desc"), limit(50)); const unsubChat = onSnapshot(chatQuery, (snapshot) => { chatMessagesEl.innerHTML = ''; snapshot.docs.reverse().forEach(doc => { const msg = doc.data(); const p = document.createElement('p'); p.innerHTML = `<strong>${msg.senderName}:</strong> ${msg.text}`; chatMessagesEl.appendChild(p); }); chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight; }); gameState.unsubscribes.push(unsubChat); }

        function main() {
            resizeCanvas();
            const urlParams = new URLSearchParams(window.location.search);
            let worldParam = urlParams.get('world');
            if (!worldParam) {
                worldParam = `world_${Math.random().toString(36).substr(2, 9)}`;
            }
            gameState.worldId = worldParam;
            initFirebase();
        }
        main();
    </script>
</body>
</html>

